import KeyActionBinder from './KeyActionBinder';
import Utils from './Utils';
/**
 * Information on a keyboard event filter
 */
export default class KeyboardAxisBinding {
    // ================================================================================================================
    // CONSTRUCTOR ----------------------------------------------------------------------------------------------------
    constructor(keyCodeA, keyCodeB, keyLocationA, keyLocationB, transitionTimeSeconds) {
        this.keyCodeA = keyCodeA;
        this.keyLocationA = keyLocationA;
        this.keyCodeB = keyCodeB;
        this.keyLocationB = keyLocationB;
        this.transitionTime = transitionTimeSeconds * 1000;
        this.timeLastChange = NaN;
        this.targetValue = this.previousValue = 0;
    }
    // ================================================================================================================
    // PUBLIC INTERFACE -----------------------------------------------------------------------------------------------
    matchesKeyboardKeyStart(keyCode, keyLocation) {
        return (this.keyCodeA == keyCode || this.keyCodeA == KeyActionBinder.KeyCodes.ANY) && (this.keyLocationA == keyLocation || this.keyLocationA == KeyActionBinder.KeyLocations.ANY);
    }
    matchesKeyboardKeyEnd(keyCode, keyLocation) {
        return (this.keyCodeB == keyCode || this.keyCodeB == KeyActionBinder.KeyCodes.ANY) && (this.keyLocationB == keyLocation || this.keyLocationB == KeyActionBinder.KeyLocations.ANY);
    }
    // ================================================================================================================
    // ACCESSOR INTERFACE ---------------------------------------------------------------------------------------------
    get value() {
        // TODO: this is linear.. add some easing?
        if (isNaN(this.timeLastChange))
            return this.targetValue;
        return Utils.map(Date.now(), this.timeLastChange, this.timeLastChange + this.currentTransitionTime, this.previousValue, this.targetValue, true);
    }
    set value(newValue) {
        if (newValue != this.targetValue) {
            this.previousValue = this.value;
            this.targetValue = newValue;
            this.currentTransitionTime = Utils.map(Math.abs(this.targetValue - this.previousValue), 0, 1, 0, this.transitionTime);
            this.timeLastChange = Date.now();
        }
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvcmUvS2V5Ym9hcmRBeGlzQmluZGluZy50cyJdLCJuYW1lcyI6WyJLZXlib2FyZEF4aXNCaW5kaW5nIiwiS2V5Ym9hcmRBeGlzQmluZGluZy5jb25zdHJ1Y3RvciIsIktleWJvYXJkQXhpc0JpbmRpbmcubWF0Y2hlc0tleWJvYXJkS2V5U3RhcnQiLCJLZXlib2FyZEF4aXNCaW5kaW5nLm1hdGNoZXNLZXlib2FyZEtleUVuZCIsIktleWJvYXJkQXhpc0JpbmRpbmcudmFsdWUiXSwibWFwcGluZ3MiOiJPQUFPLGVBQWUsTUFBTSxtQkFBbUI7T0FDeEMsS0FBSyxNQUFNLFNBQVM7QUFFM0I7O0dBRUc7QUFDSDtJQWlCQ0EsbUhBQW1IQTtJQUNuSEEsbUhBQW1IQTtJQUVuSEEsWUFBWUEsUUFBZUEsRUFBRUEsUUFBZUEsRUFBRUEsWUFBbUJBLEVBQUVBLFlBQW1CQSxFQUFFQSxxQkFBNEJBO1FBQ25IQyxJQUFJQSxDQUFDQSxRQUFRQSxHQUFHQSxRQUFRQSxDQUFDQTtRQUN6QkEsSUFBSUEsQ0FBQ0EsWUFBWUEsR0FBR0EsWUFBWUEsQ0FBQ0E7UUFDakNBLElBQUlBLENBQUNBLFFBQVFBLEdBQUdBLFFBQVFBLENBQUNBO1FBQ3pCQSxJQUFJQSxDQUFDQSxZQUFZQSxHQUFHQSxZQUFZQSxDQUFDQTtRQUVqQ0EsSUFBSUEsQ0FBQ0EsY0FBY0EsR0FBR0EscUJBQXFCQSxHQUFHQSxJQUFJQSxDQUFDQTtRQUVuREEsSUFBSUEsQ0FBQ0EsY0FBY0EsR0FBR0EsR0FBR0EsQ0FBQ0E7UUFDMUJBLElBQUlBLENBQUNBLFdBQVdBLEdBQUdBLElBQUlBLENBQUNBLGFBQWFBLEdBQUdBLENBQUNBLENBQUNBO0lBQzNDQSxDQUFDQTtJQUdERCxtSEFBbUhBO0lBQ25IQSxtSEFBbUhBO0lBRTVHQSx1QkFBdUJBLENBQUNBLE9BQWNBLEVBQUVBLFdBQWtCQTtRQUNoRUUsTUFBTUEsQ0FBQ0EsQ0FBQ0EsSUFBSUEsQ0FBQ0EsUUFBUUEsSUFBSUEsT0FBT0EsSUFBSUEsSUFBSUEsQ0FBQ0EsUUFBUUEsSUFBSUEsZUFBZUEsQ0FBQ0EsUUFBUUEsQ0FBQ0EsR0FBR0EsQ0FBQ0EsSUFBSUEsQ0FBQ0EsSUFBSUEsQ0FBQ0EsWUFBWUEsSUFBSUEsV0FBV0EsSUFBSUEsSUFBSUEsQ0FBQ0EsWUFBWUEsSUFBSUEsZUFBZUEsQ0FBQ0EsWUFBWUEsQ0FBQ0EsR0FBR0EsQ0FBQ0EsQ0FBQ0E7SUFDbkxBLENBQUNBO0lBRU1GLHFCQUFxQkEsQ0FBQ0EsT0FBY0EsRUFBRUEsV0FBa0JBO1FBQzlERyxNQUFNQSxDQUFDQSxDQUFDQSxJQUFJQSxDQUFDQSxRQUFRQSxJQUFJQSxPQUFPQSxJQUFJQSxJQUFJQSxDQUFDQSxRQUFRQSxJQUFJQSxlQUFlQSxDQUFDQSxRQUFRQSxDQUFDQSxHQUFHQSxDQUFDQSxJQUFJQSxDQUFDQSxJQUFJQSxDQUFDQSxZQUFZQSxJQUFJQSxXQUFXQSxJQUFJQSxJQUFJQSxDQUFDQSxZQUFZQSxJQUFJQSxlQUFlQSxDQUFDQSxZQUFZQSxDQUFDQSxHQUFHQSxDQUFDQSxDQUFDQTtJQUNuTEEsQ0FBQ0E7SUFHREgsbUhBQW1IQTtJQUNuSEEsbUhBQW1IQTtJQUVuSEEsSUFBV0EsS0FBS0E7UUFDZkksMENBQTBDQTtRQUMxQ0EsRUFBRUEsQ0FBQ0EsQ0FBQ0EsS0FBS0EsQ0FBQ0EsSUFBSUEsQ0FBQ0EsY0FBY0EsQ0FBQ0EsQ0FBQ0E7WUFBQ0EsTUFBTUEsQ0FBQ0EsSUFBSUEsQ0FBQ0EsV0FBV0EsQ0FBQ0E7UUFDeERBLE1BQU1BLENBQUNBLEtBQUtBLENBQUNBLEdBQUdBLENBQUNBLElBQUlBLENBQUNBLEdBQUdBLEVBQUVBLEVBQUVBLElBQUlBLENBQUNBLGNBQWNBLEVBQUVBLElBQUlBLENBQUNBLGNBQWNBLEdBQUdBLElBQUlBLENBQUNBLHFCQUFxQkEsRUFBRUEsSUFBSUEsQ0FBQ0EsYUFBYUEsRUFBRUEsSUFBSUEsQ0FBQ0EsV0FBV0EsRUFBRUEsSUFBSUEsQ0FBQ0EsQ0FBQ0E7SUFDakpBLENBQUNBO0lBRURKLElBQVdBLEtBQUtBLENBQUNBLFFBQWVBO1FBQy9CSSxFQUFFQSxDQUFDQSxDQUFDQSxRQUFRQSxJQUFJQSxJQUFJQSxDQUFDQSxXQUFXQSxDQUFDQSxDQUFDQSxDQUFDQTtZQUNsQ0EsSUFBSUEsQ0FBQ0EsYUFBYUEsR0FBR0EsSUFBSUEsQ0FBQ0EsS0FBS0EsQ0FBQ0E7WUFDaENBLElBQUlBLENBQUNBLFdBQVdBLEdBQUdBLFFBQVFBLENBQUNBO1lBQzVCQSxJQUFJQSxDQUFDQSxxQkFBcUJBLEdBQUdBLEtBQUtBLENBQUNBLEdBQUdBLENBQUNBLElBQUlBLENBQUNBLEdBQUdBLENBQUNBLElBQUlBLENBQUNBLFdBQVdBLEdBQUdBLElBQUlBLENBQUNBLGFBQWFBLENBQUNBLEVBQUVBLENBQUNBLEVBQUVBLENBQUNBLEVBQUVBLENBQUNBLEVBQUVBLElBQUlBLENBQUNBLGNBQWNBLENBQUNBLENBQUNBO1lBQ3RIQSxJQUFJQSxDQUFDQSxjQUFjQSxHQUFHQSxJQUFJQSxDQUFDQSxHQUFHQSxFQUFFQSxDQUFDQTtRQUNsQ0EsQ0FBQ0E7SUFDRkEsQ0FBQ0E7QUFDRkosQ0FBQ0E7QUFBQSIsImZpbGUiOiJjb3JlL0tleWJvYXJkQXhpc0JpbmRpbmcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgS2V5QWN0aW9uQmluZGVyIGZyb20gJy4vS2V5QWN0aW9uQmluZGVyJztcclxuaW1wb3J0IFV0aWxzIGZyb20gJy4vVXRpbHMnO1xyXG5cclxuLyoqXHJcbiAqIEluZm9ybWF0aW9uIG9uIGEga2V5Ym9hcmQgZXZlbnQgZmlsdGVyXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLZXlib2FyZEF4aXNCaW5kaW5nIHtcclxuXHJcblx0Ly8gUHJvcGVydGllc1xyXG5cdHB1YmxpYyBrZXlDb2RlQTpudW1iZXI7XHJcblx0cHVibGljIGtleUxvY2F0aW9uQTpudW1iZXI7XHJcblxyXG5cdHB1YmxpYyBrZXlDb2RlQjpudW1iZXI7XHJcblx0cHVibGljIGtleUxvY2F0aW9uQjpudW1iZXI7XHJcblxyXG5cdHB1YmxpYyB0cmFuc2l0aW9uVGltZTpudW1iZXI7XHRcdFx0Ly8gVGltZSB0byB0cmFuc2l0aW9uIHZhbHVlcyBmcm9tIDAgdG8gMSwgaW4gbXMgKHRoZSBhY3R1YWwgdHJhbnNpdGlvbiB0aW1lIHdpbGwgYmUgc2hvcnRlciwgdGhpcyBpcyBmb3IgdGhlIGZ1bGwgcmFuZ2UpXHJcblxyXG5cdHByaXZhdGUgdGltZUxhc3RDaGFuZ2U6bnVtYmVyO1x0XHRcdFxyXG5cdHByaXZhdGUgcHJldmlvdXNWYWx1ZTpudW1iZXI7XHJcblx0cHJpdmF0ZSB0YXJnZXRWYWx1ZTpudW1iZXI7XHRcdFx0XHQvLyAtMS4uMVxyXG5cdHByaXZhdGUgY3VycmVudFRyYW5zaXRpb25UaW1lOm51bWJlcjtcdC8vIFRpbWUgZm9yIHRoZSBjdXJyZW50IGNoYW5nZVxyXG5cclxuXHJcblx0Ly8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cdC8vIENPTlNUUlVDVE9SIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcblx0Y29uc3RydWN0b3Ioa2V5Q29kZUE6bnVtYmVyLCBrZXlDb2RlQjpudW1iZXIsIGtleUxvY2F0aW9uQTpudW1iZXIsIGtleUxvY2F0aW9uQjpudW1iZXIsIHRyYW5zaXRpb25UaW1lU2Vjb25kczpudW1iZXIpIHtcclxuXHRcdHRoaXMua2V5Q29kZUEgPSBrZXlDb2RlQTtcclxuXHRcdHRoaXMua2V5TG9jYXRpb25BID0ga2V5TG9jYXRpb25BO1xyXG5cdFx0dGhpcy5rZXlDb2RlQiA9IGtleUNvZGVCO1xyXG5cdFx0dGhpcy5rZXlMb2NhdGlvbkIgPSBrZXlMb2NhdGlvbkI7XHJcblxyXG5cdFx0dGhpcy50cmFuc2l0aW9uVGltZSA9IHRyYW5zaXRpb25UaW1lU2Vjb25kcyAqIDEwMDA7XHJcblxyXG5cdFx0dGhpcy50aW1lTGFzdENoYW5nZSA9IE5hTjtcclxuXHRcdHRoaXMudGFyZ2V0VmFsdWUgPSB0aGlzLnByZXZpb3VzVmFsdWUgPSAwO1xyXG5cdH1cclxuXHJcblxyXG5cdC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHQvLyBQVUJMSUMgSU5URVJGQUNFIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cdHB1YmxpYyBtYXRjaGVzS2V5Ym9hcmRLZXlTdGFydChrZXlDb2RlOm51bWJlciwga2V5TG9jYXRpb246bnVtYmVyKTpib29sZWFuIHtcclxuXHRcdHJldHVybiAodGhpcy5rZXlDb2RlQSA9PSBrZXlDb2RlIHx8IHRoaXMua2V5Q29kZUEgPT0gS2V5QWN0aW9uQmluZGVyLktleUNvZGVzLkFOWSkgJiYgKHRoaXMua2V5TG9jYXRpb25BID09IGtleUxvY2F0aW9uIHx8IHRoaXMua2V5TG9jYXRpb25BID09IEtleUFjdGlvbkJpbmRlci5LZXlMb2NhdGlvbnMuQU5ZKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBtYXRjaGVzS2V5Ym9hcmRLZXlFbmQoa2V5Q29kZTpudW1iZXIsIGtleUxvY2F0aW9uOm51bWJlcik6Ym9vbGVhbiB7XHJcblx0XHRyZXR1cm4gKHRoaXMua2V5Q29kZUIgPT0ga2V5Q29kZSB8fCB0aGlzLmtleUNvZGVCID09IEtleUFjdGlvbkJpbmRlci5LZXlDb2Rlcy5BTlkpICYmICh0aGlzLmtleUxvY2F0aW9uQiA9PSBrZXlMb2NhdGlvbiB8fCB0aGlzLmtleUxvY2F0aW9uQiA9PSBLZXlBY3Rpb25CaW5kZXIuS2V5TG9jYXRpb25zLkFOWSk7XHJcblx0fVxyXG5cclxuXHJcblx0Ly8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cdC8vIEFDQ0VTU09SIElOVEVSRkFDRSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcblx0cHVibGljIGdldCB2YWx1ZSgpOm51bWJlciB7XHJcblx0XHQvLyBUT0RPOiB0aGlzIGlzIGxpbmVhci4uIGFkZCBzb21lIGVhc2luZz9cclxuXHRcdGlmIChpc05hTih0aGlzLnRpbWVMYXN0Q2hhbmdlKSkgcmV0dXJuIHRoaXMudGFyZ2V0VmFsdWU7XHJcblx0XHRyZXR1cm4gVXRpbHMubWFwKERhdGUubm93KCksIHRoaXMudGltZUxhc3RDaGFuZ2UsIHRoaXMudGltZUxhc3RDaGFuZ2UgKyB0aGlzLmN1cnJlbnRUcmFuc2l0aW9uVGltZSwgdGhpcy5wcmV2aW91c1ZhbHVlLCB0aGlzLnRhcmdldFZhbHVlLCB0cnVlKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBzZXQgdmFsdWUobmV3VmFsdWU6bnVtYmVyKSB7XHJcblx0XHRpZiAobmV3VmFsdWUgIT0gdGhpcy50YXJnZXRWYWx1ZSkge1xyXG5cdFx0XHR0aGlzLnByZXZpb3VzVmFsdWUgPSB0aGlzLnZhbHVlO1xyXG5cdFx0XHR0aGlzLnRhcmdldFZhbHVlID0gbmV3VmFsdWU7XHJcblx0XHRcdHRoaXMuY3VycmVudFRyYW5zaXRpb25UaW1lID0gVXRpbHMubWFwKE1hdGguYWJzKHRoaXMudGFyZ2V0VmFsdWUgLSB0aGlzLnByZXZpb3VzVmFsdWUpLCAwLCAxLCAwLCB0aGlzLnRyYW5zaXRpb25UaW1lKTtcclxuXHRcdFx0dGhpcy50aW1lTGFzdENoYW5nZSA9IERhdGUubm93KCk7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcbiJdLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==